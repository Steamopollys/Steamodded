[manifest]
version = "1.0.0"
dump_lua = true
priority = 0

### Playing Card API

# Game:init_game_object()
[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = 'function Game:init_game_object()'
position = 'after'
match_indent = true
payload = '''
	local cards_played = {}
	for _,v in ipairs(SMODS.Rank.obj_buffer) do
		cards_played[v] = { suits = {}, total = 0 }
	end
'''

[[patches]]
[patches.regex]
target = "game.lua"
pattern = '(?<indent>[\t ]*)cards_played = \{\n(.*\n){13}[\t ]*\},'
position = 'at'
line_prepend = '$indent'
payload = '''
	cards_played = cards_played,
	disabled_suits = {},
	disabled_ranks = {},
'''

# Game:start_run()
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "if self.GAME.starting_params.erratic_suits_and_ranks then _, k = pseudorandom_element(G.P_CARDS, pseudoseed('erratic')) end"
position = 'at'
match_indent = true
payload = '''if self.GAME.starting_params.erratic_suits_and_ranks then _, k = pseudorandom_element(G.P_CARDS, pseudoseed('erratic'))
v = G.P_CARDS[k] end'''

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = 'local _r, _s = string.sub(k, 3, 3), string.sub(k, 1, 1)'
position = 'at'
match_indent = true
payload = 'local _r, _s = SMODS.Ranks[v.value].card_key, SMODS.Suits[v.suit].card_key'

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = 'local card_protos = nil'
position = 'after'
match_indent = true
payload = '''
local remove_suits = {}
G.GAME.disabled_suits = {}
for k, v in pairs(SMODS.Suits) do
	if v.should_register and type(v.should_register) == 'function' then
		G.GAME.disabled_suits[k] = not v:should_register(args, self.GAME.selected_back) or nil
		-- unregister playing cards
		if G.GAME.disabled_suits[k] then v:disable() end
	else
		G.GAME.disabled_suits[k] = nil
		v:populate()
		if v.should_add_to_deck and type(v.should_add_to_deck) == 'function' then
			-- remove cards from starting deck
			remove_suits[v.card_key] = not v:should_add_to_deck(args, self.GAME.selected_back)
		end
	end
end
local remove_ranks = {}
G.GAME.disabled_ranks = {}
for k, v in pairs(SMODS.Suits) do
	if v.should_register and type(v.should_register) == 'function' then
		G.GAME.disabled_ranks[k] = not v:should_register(args, self.GAME.selected_back) or nil
		if G.GAME.disabled_ranks[k] then v:disable() end
	else
		G.GAME.disabled_suits[k] = nil
		v:populate()
		if v.should_add_to_deck and type(v.should_add_to_deck) == 'function' then
			remove_ranks[v.card_key] = not v:should_add_to_deck(args, self.GAME.selected_back)
		end
	end
end
'''

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "if self.GAME.starting_params.no_faces and (_r == 'K' or _r == 'Q' or _r == 'J') then keep = false end"
position = 'at'
match_indent = true
payload = '''
if self.GAME.starting_params.no_faces and SMODS.Ranks[v.value].face then keep = false end
if remove_suits[_s] then keep = false end
if remove_ranks[_r] then keep = false end
'''

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "table.sort(G.playing_cards, function (a, b) return a.playing_card > b.playing_card end )"
position = 'before'
match_indent = true
payload = '''
for k, _ in pairs(G.GAME.disabled_suits) do
	local s = SMODS.Suits[k]
	if s then s:disable() end
end
for k, _ in pairs(G.GAME.disabled_ranks) do
	local s = SMODS.Ranks[k]
	if s then s:disable() end
end
'''

# loc_colour()
[[patches]]
[patches.pattern]
target = 'functions/misc_functions.lua'
pattern = 'return G.ARGS.LOC_COLOURS[_c] or _default or G.C.UI.TEXT_DARK'
position = 'before'
match_indent = true
payload = '''
	for _, v in ipairs(SMODS.ConsumableType.obj_buffer) do
		G.ARGS.LOC_COLOURS[v:lower()] = G.C.SECONDARY_SET[v] 
	end
	for _, v in ipairs(SMODS.Suit.obj_buffer) do
		G.ARGS.LOC_COLOURS[v:lower()] = G.C.SUITS[v]
	end
'''

# get_flush()
[[patches]]
[patches.regex]
target = "functions/misc_functions.lua"
pattern = '(?<indent>[\t ]*)local suits = \{\n[\t ]*"Spades",\n[\t ]*"Hearts",\n[\t ]*"Clubs",\n[\t ]*"Diamonds"\n[\t ]*\}\n[\t ]*if #hand > 5 or (?<restcond>#hand < \(5 - \(four_fingers and 1 or 0\)\) then return ret else)'
position = 'at'
line_prepend = '$indent'
payload = '''
local suits = SMODS.Suit.obj_buffer
if $restcond
'''

# get_X_same()
[[patches]]
[patches.pattern]
target = 'functions/misc_functions.lua'
pattern = 'local vals = {{},{},{},{},{},{},{},{},{},{},{},{},{},{}}'
position = 'at'
match_indent = true
payload = '''
local vals = {}
for i = 1, SMODS.Rank.max_id.value do
	vals[i] = {}
end
'''

# Card:get_nominal()
[[patches]]
[patches.regex]
target = "card.lua"
pattern = 'function Card:get_nominal\(mod\)\n([\t ]+.*\n)*end'
position = 'at'
payload = '''
function Card:get_nominal(mod)
	local mult = 1
	if mod == 'suit' then mult = 10000 end
	if self.ability.effect == 'Stone Card' then mult = -10000 end
	return 10*self.base.nominal + self.base.suit_nominal*mult + (self.base.suit_nominal_original or 0)*0.0001*mult + 10*self.base.face_nominal + 0.000001*self.unique_val
end
'''

# Card:set_base()
[[patches]]
[patches.regex]
target = 'card.lua'
pattern = "(?<indent>[\t ]*)if self.base.value == '2' then self.base.nominal = 2; self.base.id = 2\n([\t ]+elseif .*\n)*"
position = 'at'
line_prepend = '$indent'
payload = '''
local rank = SMODS.Ranks[self.base.value] or {}
self.base.nominal = rank.nominal or 0
self.base.face_nominal = rank.face_nominal or 0
self.base.id = rank.id
'''

[[patches]]
[patches.regex]
target = 'card.lua'
pattern = "(?<indent>[\t ]*)if self.base.suit == 'Diamonds' then self.base.suit_nominal = 0.01; self.base.suit_nominal_original = suit_base_nominal_original or 0.001 \n([\t ]+elseif .*\n)*"
position = 'at'
line_prepend = '$indent'
payload = '''
local suit = SMODS.Suits[self.base.suit] or {}
self.base.suit_nominal = suit.suit_nominal or 0
self.base.suit_nominal_original = suit_base_nominal_original or suit.suit_nominal or 0
'''

# Card:change_suit()
[[patches]]
[patches.regex]
target = 'card.lua'
pattern = "(?<indent>[\t ]*)local new_code = [\\s\\S]*?local new_val = [\\s\\S]*?local new_card = G.P_CARDS\\[new_code..new_val\\]"
position = 'at'
line_prepend = '$indent'
payload = '''
local new_code = SMODS.Suits[new_suit].card_key
local new_val = SMODS.Ranks[self.base.value].card_key
local new_card = G.P_CARDS[new_code..'_'..new_val]
'''

# Card:is_face()
[[patches]]
[patches.regex]
target = 'card.lua'
pattern = "(?<indent>[\t ]*)if id == 11 or id == 12 or id == 13 or next\\(find_joker\\(\"Pareidolia\"\\)\\) then"
position = 'at'
line_prepend = '$indent'
payload = '''
local rank = SMODS.Ranks[self.base.value]
if not id then return end
if (id > 0 and rank.face) or next(find_joker("Pareidolia")) then
'''


# tally_sprite()
[[patches]]
[patches.regex]
target = 'functions/UI_definitions.lua'
pattern = '(?<start>[\t ]*local t_s = Sprite\(0,0,0.5,0.5,)G.ASSET_ATLAS\[.*?\](?<rest>.*?\))'
position = 'at'
payload = '$start G.ASSET_ATLAS[suit and SMODS.Suits[suit][G.SETTINGS.colourblind_option and "hc_ui_atlas" or "lc_ui_atlas"]] or G.ASSET_ATLAS[("ui_"..(G.SETTINGS.colourblind_option and "2" or "1"))]$rest'

[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = 'function tally_sprite(pos, value, tooltip)'
position = 'at'
match_indent = true
payload = 'function tally_sprite(pos, value, tooltip, suit)'

# G.UIDEF.challenge_description_tab()
[[patches]]
[patches.regex]
target = 'functions/UI_definitions.lua'
pattern = "(?<indent>[\t ]*)local SUITS = \\{(\n.*){5}\n[\t ]*local suit_map = \\{'S', 'H', 'C', 'D'\\}"
position = 'at'
line_prepend = '$indent'
payload = '''
local SUITS = {}
local suit_map = {}
for i = #SMODS.Suit.obj_buffer, 1, -1 do
	local suit = SMODS.Suits[SMODS.Suit.obj_buffer[i]]
	SUITS[suit.card_key] = {}
	suit_map[#suit_map+1] = suit.card_key
end
'''

[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = 'local _r, _s = string.sub(k, 3, 3), string.sub(k, 1, 1)'
position = 'at'
match_indent = true
payload = 'local _r, _s = SMODS.Ranks[v.value].card_key, SMODS.Suits[v.suit].card_key'

[[patches]]
[patches.regex]
target = 'functions/UI_definitions.lua'
pattern = '(?<indent>[\t ]*)for j = 1, 4 do\n[\t ]*(?<mid>if SUITS\[suit_map\[j\]\]\[1\] then\n[\t ]*table.sort.*(\n.*)*?)\n[\t ]*0\.42\*G.CARD_H,'
position = 'at'
line_prepend = '$indent'
payload = '''
local num_suits = 0
for j = 1, #suit_map do
	if SUITS[suit_map[j]][1] then num_suits = num_suits + 1 end
end
for j = 1, #suit_map do
	$mid			
			(0.42 - (num_suits <= 4 and 0 or num_suits >= 8 and 0.28 or 0.07 * (num_suits - 4))) * G.CARD_H,
'''
